## Context

The NixOS multi-instance service module (`nix/nixos/module.nix`) currently accepts OpenCode configuration via `opencodeCfg`, a `listOf anything` option that passes raw module expressions to `mkOpenCodeConfig`. This works but creates ergonomic friction:

- Users must understand the module-list pattern (`opencodeCfg = [ { opencode.theme = "dark"; } ]`) rather than setting options directly.
- The `opencode.*` prefix inside modules is redundant when the context is already "this instance's config".
- There's no way to override the generated config with a pre-built JSON file.
- The `"$schema"` option pollutes the Nix surface — users must either set it or ignore it, when it should be auto-generated.

Standalone config generation (`mkOpenCodeConfig`, `wrapOpenCode`) must remain fully functional for non-service workflows.

## Goals / Non-Goals

**Goals:**

- Add `services.opencode.instances.<name>.config` as a native NixOS submodule that mirrors the `opencode.*` option tree, minus the `opencode.` prefix.
- Add `services.opencode.instances.<name>.configFile` as a path option defaulting to the JSON generated from `config`.
- Auto-inject `"$schema"` into generated JSON output without requiring it in Nix input.
- Preserve backward compatibility: `opencodeCfg` continues to work (deprecated).
- Keep `mkOpenCodeConfig` and `wrapOpenCode` unchanged for standalone use.

**Non-Goals:**

- Changing the internal module option tree structure in `nix/config/options/`.
- Removing `mkOpenCodeConfig` or `wrapOpenCode`.
- Supporting runtime config reloading.
- Schema validation at Nix evaluation time beyond what the module system already provides.

## Decisions

### D1: Expose config module options directly under `config`

**Choice:** Define `services.opencode.instances.<name>.config` as a submodule that reuses the existing config module definition (`nix/config/default.nix`) but strips the `opencode.` prefix so users write:

```nix
services.opencode.instances.my-agent.config = {
  model = "claude-sonnet-4-20250514";
  theme = "dark";
  agents.my-agent = { ... };
};
```

**Rationale:** The existing module system in `nix/config/` already defines all the typed options. Reusing it avoids duplication. The `opencode.` prefix was needed for standalone use where the module is at the top level; inside a NixOS instance submodule it's redundant.

**How:** In `instanceOpts`, define `config` as a submodule type whose options are the `opencode.*` options from `nix/config/default.nix`, imported so the top-level key is `config` not `config.opencode`. Concretely, use `types.submoduleWith { modules = [ ../config/default.nix ]; }` and map `config.opencode.*` to the `config.*` surface (the module system handles this naturally if we import the config module and users set values under `config.opencode.*`, but we want to strip the prefix).

**Approach:** Create a thin adapter module that takes the `nix/config/default.nix` options and re-exports them without the `opencode.` prefix. Evaluate via `lib.evalModules` with the user's `config` attrset wrapped appropriately.

**Alternative considered:** Freeform `attrsOf anything` — rejected because we'd lose type checking, which is the whole point of the config module system.

### D2: `configFile` with default derivation from `config`

**Choice:** Add `configFile` as a `types.path` option whose default value is the store path generated by evaluating `config` through `mkOpenCodeConfig`.

**Rationale:** This gives users a clean override point. If they have a pre-built `opencode.json` (from another tool, from CI, etc.), they can set `configFile = ./my-opencode.json;` and bypass Nix config evaluation entirely. If they don't set it, the default derivation is computed from `config`.

**Precedence:** `configFile` (explicit) > `config` (generated default). If user sets both `config` values AND `configFile`, the explicit `configFile` wins — the `config` values are simply unused. We should add an assertion/warning when both are explicitly set.

### D3: Auto-inject `"$schema"` in JSON output, remove from Nix options

**Choice:** Remove the `"$schema"` option from `nix/config/options/top-level.nix`. In `lib.nix`'s `mkOpenCodeConfig`, unconditionally prepend `"$schema" = "https://opencode.ai/config.json"` to the generated JSON output (after evaluation, before serialization).

**Rationale:** `"$schema"` is a JSON Schema artifact for editor tooling. It has no semantic meaning in Nix evaluation. Forcing users to set it is noise. Auto-injecting it in the output gives JSON consumers what they need without polluting the Nix API.

**Migration:** Remove the option, update examples/tests that set it. Since the option had `default = null`, most configs don't set it — impact is minimal.

### D4: Deprecate `opencodeCfg`, don't remove yet

**Choice:** Keep `opencodeCfg` functional but mark it deprecated with a warning. If both `config` and `opencodeCfg` are set, emit an error.

**Rationale:** Existing users and examples use `opencodeCfg`. A hard removal in the same change is unnecessarily disruptive. Deprecation gives migration time.

**Implementation:** Add a `warnings` entry when `opencodeCfg != []` saying to migrate to `config`. Add an assertion that `opencodeCfg` and `config` are not both non-default.

### D5: Standalone paths unchanged

**Choice:** `mkOpenCodeConfig` and `wrapOpenCode` in `lib.nix` remain as-is. They continue to accept module lists with the `opencode.*` prefix.

**Rationale:** These are the non-NixOS entrypoints. The NixOS module is the ergonomic layer on top. Changing the standalone API would be a separate concern and would break `wrapOpenCode` users who aren't using NixOS services at all.

## Risks / Trade-offs

**[Risk: Dual config paths cause confusion]** → Mitigation: Clear deprecation warnings on `opencodeCfg`; documentation update; assertion preventing both from being set simultaneously.

**[Risk: Prefix stripping adds adapter complexity]** → Mitigation: The adapter is a thin module that imports `nix/config/default.nix` and maps evaluation. NixOS module system handles merging natively; we just need the eval bridge.

**[Risk: Auto-injected `$schema` could conflict with future schema versioning]** → Mitigation: The injected value can be made configurable later if needed. For now, a single canonical URL matches upstream behavior.

**[Trade-off: `configFile` override bypasses all type checking]** → Accepted: This is intentional. Users who provide their own JSON take responsibility for validity. This is the escape hatch.
